// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"path"
	"time"

	"github.com/boreq/errors"
	"github.com/google/wire"
	"github.com/planetary-social/go-ssb/logging"
	"github.com/planetary-social/go-ssb/service/adapters"
	"github.com/planetary-social/go-ssb/service/adapters/mocks"
	"github.com/planetary-social/go-ssb/service/adapters/pubsub"
	"github.com/planetary-social/go-ssb/service/app"
	"github.com/planetary-social/go-ssb/service/app/commands"
	"github.com/planetary-social/go-ssb/service/app/queries"
	"github.com/planetary-social/go-ssb/service/domain"
	"github.com/planetary-social/go-ssb/service/domain/feeds"
	"github.com/planetary-social/go-ssb/service/domain/feeds/content/transport"
	"github.com/planetary-social/go-ssb/service/domain/feeds/formats"
	"github.com/planetary-social/go-ssb/service/domain/graph"
	"github.com/planetary-social/go-ssb/service/domain/identity"
	"github.com/planetary-social/go-ssb/service/domain/network"
	"github.com/planetary-social/go-ssb/service/domain/network/local"
	"github.com/planetary-social/go-ssb/service/domain/replication"
	transport2 "github.com/planetary-social/go-ssb/service/domain/transport"
	"github.com/planetary-social/go-ssb/service/domain/transport/boxstream"
	rpc2 "github.com/planetary-social/go-ssb/service/domain/transport/rpc"
	network2 "github.com/planetary-social/go-ssb/service/ports/network"
	pubsub2 "github.com/planetary-social/go-ssb/service/ports/pubsub"
	"github.com/planetary-social/go-ssb/service/ports/rpc"
	"github.com/sirupsen/logrus"
	"go.etcd.io/bbolt"
)

// Injectors from wire.go:

func BuildApplicationForTests() (TestApplication, error) {
	feedRepositoryMock := mocks.NewFeedRepositoryMock()
	messagePubSubMock := mocks.NewMessagePubSubMock()
	createHistoryStreamHandler := queries.NewCreateHistoryStreamHandler(feedRepositoryMock, messagePubSubMock)
	appQueries := app.Queries{
		CreateHistoryStream: createHistoryStreamHandler,
	}
	testApplication := TestApplication{
		Queries:        appQueries,
		FeedRepository: feedRepositoryMock,
		MessagePubSub:  messagePubSubMock,
	}
	return testApplication, nil
}

func BuildTransactableAdapters(tx *bbolt.Tx, private identity.Private, logger logging.Logger) (commands.Adapters, error) {
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return commands.Adapters{}, err
	}
	scuttlebutt := formats.NewScuttlebutt(marshaler)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	public := privateIdentityToPublicIdentity(private)
	graphHops := _wireHopsValue
	socialGraphRepository := adapters.NewSocialGraphRepository(tx, public, graphHops)
	boltFeedRepository := adapters.NewBoltFeedRepository(tx, rawMessageIdentifier, socialGraphRepository, scuttlebutt)
	commandsAdapters := commands.Adapters{
		Feed:        boltFeedRepository,
		SocialGraph: socialGraphRepository,
	}
	return commandsAdapters, nil
}

var (
	_wireHopsValue = hops
)

func BuildAdaptersForContactsRepository(tx *bbolt.Tx, private identity.Private, logger logging.Logger) (adapters.Repositories, error) {
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return adapters.Repositories{}, err
	}
	scuttlebutt := formats.NewScuttlebutt(marshaler)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	public := privateIdentityToPublicIdentity(private)
	graphHops := _wireGraphHopsValue
	socialGraphRepository := adapters.NewSocialGraphRepository(tx, public, graphHops)
	boltFeedRepository := adapters.NewBoltFeedRepository(tx, rawMessageIdentifier, socialGraphRepository, scuttlebutt)
	repositories := adapters.Repositories{
		Feed:  boltFeedRepository,
		Graph: socialGraphRepository,
	}
	return repositories, nil
}

var (
	_wireGraphHopsValue = hops
)

func BuildService(private identity.Private, config Config) (Service, error) {
	networkKey := boxstream.NewDefaultNetworkKey()
	handshaker, err := boxstream.NewHandshaker(private, networkKey)
	if err != nil {
		return Service{}, err
	}
	requestPubSub := pubsub.NewRequestPubSub()
	logger := newLogger(config)
	peerInitializer := transport2.NewPeerInitializer(handshaker, requestPubSub, logger)
	dialer, err := network.NewDialer(peerInitializer, logger)
	if err != nil {
		return Service{}, err
	}
	db, err := newBolt(config)
	if err != nil {
		return Service{}, err
	}
	adaptersFactory := newAdaptersFactory(private, logger)
	transactionProvider := adapters.NewTransactionProvider(db, adaptersFactory)
	redeemInviteHandler := commands.NewRedeemInviteHandler(dialer, transactionProvider, networkKey, private, requestPubSub, logger)
	followHandler := commands.NewFollowHandler(transactionProvider, private, logger)
	repositoriesFactory := newContactRepositoriesFactory(private, logger)
	boltContactsRepository := adapters.NewBoltContactsRepository(db, repositoriesFactory)
	manager := replication.NewManager(logger, boltContactsRepository)
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return Service{}, err
	}
	scuttlebutt := formats.NewScuttlebutt(marshaler)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	rawMessageHandler := commands.NewRawMessageHandler(transactionProvider, rawMessageIdentifier, logger)
	gossipReplicator, err := replication.NewGossipReplicator(manager, rawMessageHandler, logger)
	if err != nil {
		return Service{}, err
	}
	peerManager := domain.NewPeerManager(gossipReplicator, logger)
	connectHandler := commands.NewConnectHandler(dialer, peerManager, logger)
	acceptNewPeerHandler := commands.NewAcceptNewPeerHandler(peerManager)
	appCommands := app.Commands{
		RedeemInvite:  redeemInviteHandler,
		Follow:        followHandler,
		Connect:       connectHandler,
		AcceptNewPeer: acceptNewPeerHandler,
	}
	boltMessageRepository := adapters.NewBoltMessageRepository(db, rawMessageIdentifier)
	messagePubSub := pubsub.NewMessagePubSub()
	createHistoryStreamHandler := queries.NewCreateHistoryStreamHandler(boltMessageRepository, messagePubSub)
	appQueries := app.Queries{
		CreateHistoryStream: createHistoryStreamHandler,
	}
	application := app.Application{
		Commands: appCommands,
		Queries:  appQueries,
	}
	listener, err := newListener(peerInitializer, application, config, logger)
	if err != nil {
		return Service{}, err
	}
	handlerCreateHistoryStream := rpc.NewHandlerCreateHistoryStream(createHistoryStreamHandler)
	handlerBlobsGet := rpc.NewHandlerBlobsGet()
	v2 := rpc.NewMuxHandlers(handlerCreateHistoryStream, handlerBlobsGet)
	mux, err := rpc.NewMux(logger, v2)
	if err != nil {
		return Service{}, err
	}
	pubSub := pubsub2.NewPubSub(requestPubSub, mux)
	public := privateIdentityToPublicIdentity(private)
	advertiser, err := newAdvertiser(public, config)
	if err != nil {
		return Service{}, err
	}
	service := NewService(listener, pubSub, advertiser, application)
	return service, nil
}

// wire.go:

var applicationSet = wire.NewSet(wire.Struct(new(app.Application), "*"), wire.Struct(new(app.Commands), "*"), commands.NewRedeemInviteHandler, commands.NewFollowHandler, commands.NewConnectHandler, commands.NewAcceptNewPeerHandler, wire.Struct(new(app.Queries), "*"), queries.NewCreateHistoryStreamHandler, wire.Bind(new(rpc.CreateHistoryStreamQueryHandler), new(*queries.CreateHistoryStreamHandler)))

var replicatorSet = wire.NewSet(replication.NewManager, wire.Bind(new(replication.ReplicationManager), new(*replication.Manager)), replication.NewGossipReplicator, wire.Bind(new(domain.Replicator), new(*replication.GossipReplicator)))

var formatsSet = wire.NewSet(
	newFormats, formats.NewScuttlebutt, transport.NewMarshaler, wire.Bind(new(formats.Marshaler), new(*transport.Marshaler)), transport.DefaultMappings, formats.NewRawMessageIdentifier, wire.Bind(new(commands.RawMessageIdentifier), new(*formats.RawMessageIdentifier)), wire.Bind(new(adapters.RawMessageIdentifier), new(*formats.RawMessageIdentifier)),
)

var portsSet = wire.NewSet(rpc.NewMux, rpc.NewMuxHandlers, rpc.NewHandlerBlobsGet, rpc.NewHandlerCreateHistoryStream, pubsub2.NewPubSub)

var requestPubSubSet = wire.NewSet(pubsub.NewRequestPubSub, wire.Bind(new(rpc2.RequestHandler), new(*pubsub.RequestPubSub)))

var messagePubSubSet = wire.NewSet(pubsub.NewMessagePubSub, wire.Bind(new(queries.MessageSubscriber), new(*pubsub.MessagePubSub)))

var adaptersSet = wire.NewSet(adapters.NewBoltMessageRepository, wire.Bind(new(queries.FeedRepository), new(*adapters.BoltMessageRepository)))

type TestAdapters struct {
	Feed *adapters.BoltFeedRepository
}

var hops = graph.MustNewHops(3)

type TestApplication struct {
	Queries app.Queries

	FeedRepository *mocks.FeedRepositoryMock
	MessagePubSub  *mocks.MessagePubSubMock
}

func newAdvertiser(l identity.Public, config Config) (*local.Advertiser, error) {
	return local.NewAdvertiser(l, config.ListenAddress)
}

func newListener(
	initializer network2.ServerPeerInitializer, app2 app.Application,

	config Config,
	logger logging.Logger,
) (*network2.Listener, error) {
	return network2.NewListener(initializer, app2, config.ListenAddress, logger)
}

func newAdaptersFactory(local2 identity.Private, logger logging.Logger) adapters.AdaptersFactory {
	return func(tx *bbolt.Tx) (commands.Adapters, error) {
		return BuildTransactableAdapters(tx, local2, logger)
	}
}

func newContactRepositoriesFactory(local2 identity.Private, logger logging.Logger) adapters.RepositoriesFactory {
	return func(tx *bbolt.Tx) (adapters.Repositories, error) {
		return BuildAdaptersForContactsRepository(tx, local2, logger)
	}
}

func newBolt(config Config) (*bbolt.DB, error) {
	filename := path.Join(config.DataDirectory, "database.bolt")
	b, err := bbolt.Open(filename, 0600, &bbolt.Options{Timeout: 5 * time.Second})
	if err != nil {
		return nil, errors.Wrap(err, "could not open the database, is something else reading it?")
	}
	return b, nil
}

func privateIdentityToPublicIdentity(p identity.Private) identity.Public {
	return p.Public()
}

func newLogger(config Config) logging.Logger {
	log := logrus.New()
	log.SetLevel(logrus.TraceLevel)
	return logging.NewLogrusLogger(log, "main", config.LoggingLevel)
}

func newFormats(
	s *formats.Scuttlebutt,
) []feeds.FeedFormat {
	return []feeds.FeedFormat{
		s,
	}
}
